# 1
练习
每天一问

3/3

## this
this代表当前对象本身，本质是当前对象  
普通方法中this指向调用该方法的对象  
构造方法中，this指向正要初始化的对象  
this（）调用重载的构造方法，避免相同的初始化代码。但只能在构造方法中用且必须位于第一句  
this不能用于静态方法，//因为在两个不同的区域？this在堆，staic在方法区  
> static的含义为首先加载到内存中,当程序开始运行时,会首先将被static修饰的类,方法和变量加载到内存中.因此static方法中不可直接访问非static的成员,因为此时非static的成员还没有被创建.
## static
静态变量，方法（类变量，方法）：static声明的属性或方法  
static的属性和方法同属于类。生命周期与类相同，  
static变量只有一份，一般用“类名/类变量，方法”来调用  
static方法中不可直接访问非static的成员  

## 静态初始化块
构造方法用于对象普通属性的初始化  
静态初始化块用于类的初始化，初始化一些静态的属性（静态初始化块中不能直接访问非static成员）  

## 变量的分类和作用域
局部变量属于方法  
成员变量属于对象  
静态变量属于类  

> 这里用makedown语法整理成表格形式.

  | **类型** |    **声明位置**    |   **从属**  |   **生命周期（作用域）**   |
  |:-:      |:-:                 |:-:          |:-: |
  |局部变量  |  方法或语句块内部   | 方法/语句块  | 从声明处开始，到方法或语句块结束|
  |成员变量  | 类的内部，方法的外部|    对象    | 对象创建，成员变量也跟着创建。对象消失，同样消失|
  |静态变量  | 类内部，static修饰 |     类     | 类被加载，静态变量就有效 |
  
3/4
## 包机制（package,import）
包（package）相当于文件夹，用于管理类，用于解决类的重名问题  

package的使用有两个要点
1. 通常是类的第一句非注释性语句
2. 包名:域名倒着写即可，便于内部管理类

例：com.qiao | com.qiao.mu //这两个包虽然看似有包含关系，但其实是两个独立的包

| **Java中的常用包** | **说明** |
|       :-:         |   :-:    |
|java.lang          | 包含一些Java语言的核心类 |
|java.awt           | 包含了构成抽象窗口工具集（abstract window toolkits）的多个类，这些类被用来构建和管理应用程序的图形用户界面 |
|java.net           |包含执行域网络相关的操作的类 | 
|java.io            |包含能提供多种输入/输出功能的类 | 
|java.util          |包含一些实用工具类|

3/5
## 导入类import

如果要使用其他报的类，需使用import，从而在本类中直接通过类名来调用，否则就需要书写类的完整包名和类名。

**注意点**

Java会默认导入java.lang 包下所有的类，因此这些类可以直接使用
如果导入两个同名的类，只能用包名+类名来显示调用相关类  //偶尔会遇到重复的情况，遇到了就把包名写全来区分
例: com.qiao.mu.123 = new com.qiao.mu.123();

import java.util.*;  //这里的 .* 的作用是导入该包下所有类，会降低编译速度，但不会降低运行速度，因为实际只会运行使用的类

## 静态导入（static import）

 作用是用于导入指定类的静态属性和静态方法，让我们可以直接使用它们
 
 **例**
 ```
 import static java.lang.Math.*;  //导入Math类的所有静态属性
 
 import static java lang Math.PI; //导入Math类的PI属性
 ```
 //导入之后
 
 System.out.println(PI);   //这里原本需要输入（Math.PI）,因为上面已经导入，所以直接输入(PI)即可
> 前面这些概念性的可以提提速,给咱们后面集合框架,多线程,反射多留点时间.3月份务必拿下javaSE

3/6

## 面向对象的三大特征

**继承**   **封装**   **多态**

## 面向对象的三大特征_继承

**继承（extends）**
继承有两个主要作用

1. 代码复用，更容易实现类的扩展
2. 方便建模

继承的使用要点
1. 父类也称作超类，基类。    子类也称作；派生类等
2. java中只有单继承，没有像C++那样的多继承，因为多继承会引起混乱，使得继承链过于复杂，难以维护
3. java中没有多继承，但接口有多继承
> 接口和类的关系一般称为实现(implement)
4. 子类继承父类，可以得到父类的全部属性和方法（除了父类的构造方法），但不意味可以直接访问（比如，父类私有的属性方法）
5. 如果定义一个类时，没有调用 extends,则他的父类是： java.lang.Object。
> Java中,所有类都直接或间接的继承于Object类.

**运算符（instanceof）**

instanceof是二元运算符，左边是对象，右边是类；

当对象是右边类或子类所创建对象时，返回true;否则，返回false

## 方法重写（override）

子类重写父类的方法，可以用自身行为替换父类行为（其实是覆盖掉了，优先读取子类，但父类也还在）。重写是实现多态的必要条件。

方法重写需要符合的3个要点

1. 方法名，形参列表相同
2. 返回值类型和声明异常类型，子类小于等于父类（子可以返回子，但子不能返回父）。
3. 访问权限，子类大于等于父类

## final 关键字

final 关键字的作用：

**修饰变量**：被他修饰的变量不可改变（变成常量了）。一旦赋了初值，就不能被重新赋值（只能赋值一次）。

**修饰方法**：该方法不可被子类重写，但可以被重载

**修饰类**：修饰的类不能被继承，比如：Math，String等

//相当于最终形态，不可再改变

## 组合

组合后可以复用对方的属性和方法，除了继承外组合也可以实现代码的复用，组合的核心是将父类对象作为子类的属性

组合可以组合多段代码

3/7

## Object类

所有类都是Object类的子类，也具备Object类的所有子类
> 这句话后半句没看懂

**Object类的基本特性**

1. Object类是所有类的父类，所有的Java对象都拥有Object类的属性和方法
2. 如果在类的声明中未使用extends,则默认继承Object类

## ==和equals方法
> 这里很重要,尤其在对比字符串内容时,一定记住要用equals方法.

“==”代表比较双方是否相同。如果是基本类型则表示值相等，如果是引用类型则表示地址相等及时同一个对象

equals() 提供定义“对象内容相等” 的逻辑。比如，学籍系统中认为学号相同的人就是一个人

equals()默认是比较两个对象的hashcode（约等于地址）。但可以根据需求重写equals方法。

3/8

## super

1. super“可以看做”是直接父类对象的引用。可通过suoer来访问父类中被子类覆盖度方法或属性。

2. 使用super调用普通方法，语句没有位置限制，可以再子类中随便调用。

3. 在一个类中，若是构造方法的第一行没有调用super（...）或者this（...）:那么Java默认都会调用super（），含义是调用父类的无参数构造方法

//如果把这个区域比喻成家族的话，Object是爷爷，类1是父亲，类2是孙子。孙子（类2）可以通过super访问父亲（类1），但不能直接访问爷爷（Object），但可以通过父亲（类1）进行访问。

**属性/方法的查找顺序**

例：查找变量h

1. 查找当前类中有没有 h变量

2. 依次上溯每个父类，查看每个父类中是否有h，直到Object

3. 如果没找到则出现编译错误，如果在任意步骤中找到h变量，则过程中止

**构造方法调用顺序**

构造方法第一句总是：super(...)来调用父类对应的构造方法。所以，流程就是先向上追溯到Object，然后再依次向下执行类的初始化块和构造方法，直到当前子类为止

**注：**静态初始化块调用顺序，与构造方法调用顺序一样

## 面向对象的三大特征_封装

**封装（encapsulation）**

封装的理念：

高内聚（将复杂的东西隐藏起来不需调用者知道），低耦合（让使用者更简单的调用）

**封装的优点**

提高代码的安全性

提高代码的复用性

“高内聚”：封装细节，便于修改内部代码，提高可维护性。
“低耦合”：简化外部调用，便于调用者使用，便于扩展和协作。

**封装的实现——使用访问控制符**

Java是使用“访问控制符”来控制那些细节需要封装，那些细节需要暴露的

**访问权限修饰符**
|**修饰符**                                          |**同一个类**|**同一个包中**|**子类**|**所有类**|
|:-:                                                |:-:         |:-:          |:-:    |:-:       |
|**private**//类内友好                               | ※         |             |       |          |
|**default**//包内友好 （什么都不写时默认为default）   | ※         | ※          |       |          |
|**protected**//父子友好，包内友好                    | ※         | ※          | ※    |          |
|**public** //全局友好                               | ※         | ※          | ※    | ※       |

**注：关于protected的两个细节**

1. 若父类与子类在同一个包中，子类可访问父类的protected成员，也可访问父类对象的protected成员。

2. 若子类和父类不在同一个包中，子类可访问父类的protected成员，不能访问父类对象的protected成员。

**开发中封装的简单规则：**

+ 属性一般使用private（私有）访问权限
    - 属性私有后，提供相应的get/set方法来访问相关属性，这些方法通常是public修饰的，以提供对属性的赋值与读取操作//boolean变量的get方法是is开头
+ 方法：一些只用于本类的辅助性方法可以用privat修饰，希望其他类调用的方法用public修饰。
> 今天总结的不错,加油.

3/9

**多态（polymorphism）**

多态：同一个方法调用，不同对象行为完全不同

**多态的要点：**

1. 多态是方法的多态，不是属性的多态（多态与属性无关）

2. 多态的存在有三个必要条件：继承，方法重写，父类引用指向子类对象。

3. 父类引用指向子类对象后，用该父类引用调用子类重写的方法，此时多态就出现了。

（比如总类是吃饭，子类1：吃饭用筷子，子类2：吃饭用叉子，子类3：吃饭用手抓，他们都是吃饭，但行为完全不同）

> 这是Java很重要的一个特性,一定学透,有不理解的地方及时问,进度提一提,今天内容有点少了.

3/10

## 对象的转型（casting）

1. 父类引用指向子类对象，我们称这个过程为**向上转型**，属于自动类型转换。

2. 向上转型后的父类引用变量只能调用它编译类型的方法，不能调用它运行时类型的方法。这时，需要进行类型的强制转换，也就是**向下转型**。

//因为是强制转换所以编译不会报错，但运行可能会报错，这时可以使用
  
```
   if（编译类型 instanceof 运行类型）{

    强制转换;

    方法;

}
```

**例：**假如有个Animal类

```
  Animal animal = new Dog(); //编译类型Animal，运行类型Dog。      //向上转型（自动）
  
  animal.shout();
  
  Dog a = (Dog)animal;  //向下转型（强制）
  
  a.eatMeat();
  
  if(animal instanceof Cat){    //判断，是猫的话就吃鱼
  
    Cat b = (Cat)animal;
    
    b.eatFish();
    
    }
    
}
  
```
来进行判断。//转型后还是原本的对象

> 这里详细点写,最好可以写一个实际的例子.

3/11
（晚上回来再搞）
> 学习一下makedown语法标记代码段的方式,把之前的代码段都用这种方式标记上,进度要加快点,3月已经过去三分之一了.

## 抽象类和接口

**抽象方法和抽象类**

**抽象方法**

1. 使用abstract修饰的方法，没有方法体，只有声明。

2. 定义的是一种“规范”，就是告诉子类必须要给抽象方法提供具体的实现。

**抽象类**

包含抽象方法的类就是抽象类。

通过抽象类，我们可以做到严格限制子类的设计，使子类之间更加通用。

//比如创建一个人的类，你必须会呼吸，要吃饭，得喝水才能活。不满足这些，不吃不喝不呼吸也能活，就不是人类所以无法通过编译。

**抽象类的要点**

1. 有抽象方法的类只能定义成抽象类。
2. 抽象类不能实例化，即不能用 new 来实例化抽象类。
3. 抽象类可以包含属性，方法，构造方法。但是构造方法不能用来 new 实例，只能用来被子类调用。
4. 抽象类只能用来被继承。
5. 抽象方法必须被子类实现。 

## 接口（interface）

接口就是一组规范（相当于程序里的法律），所有实现类都要遵守。//接口里只能有抽象

**接口的作用**

更加规范的对子类进行约束，做到了：规范和具体实现的分离。

接口是两个模块之间通信的标准和规范。设计模块之间的接口就相当于系统的大纲，以后做系统时往往使用的就是“面向接口”的思想来设计系统。

接口和实现类不是父子关系，是实现规则的关系。
> 差不多是这个意思,但我理解不是实现接口后必须要呼吸,而是谁需要呼吸的话,谁就来实现呼吸接口,不需要呼吸的类就不需要实现了,我理解是这样的关系,你如果没理解可以再问我一下.

> 昨天我可能没理解你的想法,是这样的,假设有三个类,人,狗,猫,他们三个类都实现了生物接口,生物接口中声明了一个呼吸方法,那这三个类都必须重写(或者说实现)呼吸方法,具体的实现方式由类内自己管理,但必须要保证这个方法大家都有实现.(也可以把人,狗,猫声明为抽象类,不过很明显不是我们讨论的范围.)
![image](https://user-images.githubusercontent.com/50293047/224560051-f213093d-4a39-4637-b8cc-6b30f43f18c5.png)
![image](https://user-images.githubusercontent.com/50293047/224560188-bf6d7319-62a3-4256-8529-d5f78c53a9ad.png)


**如何定义和使用接口**

**声明格式：**

```
    [访问修饰符] interface 接口名   [extends  父接口 1，父接口2...]  {
    
                常量定义;
                方法定义;
                }

```
**声明格式：**

+ 访问修饰符：只能是public或默认。
+ 接口名：和类名采用相同命名机制。
+ extends：接口可以多继承。
+ 常量：接口中的属性只能是常量，总是：public static final 修饰。不写也是用他们修饰，自动加。
+ 方法：接口中的方法只能是：public abstract。省略的话，它也是public abstract，自动加。

**要点**

+ 子类通过 implements来实现接口中的规范。
+ 接口不能创建实例，但可用于声明引用变量类型。
+ 一个类实现了接口，必须实现接口中所有的方法，并且这些方法只能是public的。
+ JDK1.8（不含8）之前，接口中只能包含静态常量，抽象方法。不能有普通属性，构造方法，普通方法。
+ JDK1.8（含8）后，接口中包含普通的静态方法，默认方法。

```
//飞行接口
public interface Volant{
  int flyTime = 1minute;   //常量这里 int 前面是有public static final的，不写也会自动加，不过被隐藏了
  void fly();           //方法这里也一样，void前有public abstract，不写也自动加
}
//善良接口
interface Honest{
  void helpOther();
  }
  
  class Bird implements Volant（）{
    public void fly(){                  //实现接口Volant里的方法
        System.out.println("想飞就飞");
    }
  
  class Angel implements Volant,Honest（）{
    public void fly(){                  
        System.out.println("天使能飞");
    }
    public void helpOther(){                  //同时满足两个接口
        System.out.println("天使帮助人");
    }
  }
```
> 保持住这个进度,加油.

3/12

**接口中定义静态方法和默认方法（JDK8）**

JAVA8之前，接口里的方法要求全部是抽象方法。

JAVA（含8）之后，以后允许在接口里定义默认方法和静态方法。

**1.默认方法**

Java 8及以上新版本，允许给接口添加一个非抽象的方法实现，只需要使用 default 关键字即可，这个特征又叫做默认方法（或扩展方法）。

默认方法和抽象方法的区别是抽象方法必须要被实现，默认方法不是，作为替代方式，接口可以提供默认方法的实现，所有这个接口的实现类都可以得到默认方法。

默认是普通方法，从属于对象，可以调用静态方法。但静态方法不能反过来调用默认方法。

//重写一个新方法可以直接替代默认方法，也可以直接调用默认方法，使用时一定要在方法前加 default。

**JDK8 新特性-静态方法**

JAVA 8以后，我们也可以在接口中直接定义静态方法的实现。这个静态方法直接从属于接口（接口也是类的一种），可以通过接口名调用。

如果子类中定义了相同名字的静态方法，那就是完全不同的方法了（一个从属接口，一个从属子类），直接从属于子类可以通过子类名直接调用。

**接口的多继承**

接口支持多继承，和类的继承类似，子接口 extends 父接口，会获得父接口的一些。

**例**
```
interface A{
      void testA();
}
interface B{
      void testB();
}
interface C extends A,B {   //相当于同时有了testA和testB
      void testC();
}
//这时候如果想要实现C的话，也要同时满足A和B。上个例子的天使也是多接口
```

## 字符串 String 类详解

String：就是把一堆字符穿起来，统一使用（相当于烤肉的签子）

+ String 类又称作不可变字符序列。
+ String 位于 java.lang 包中，Java 程序默认导入 java.lang 包下的所有类。
+ Java 字符串就是 **Unicode 字符序列**，例如字符串“Java”就是由4个 Unicode 字符“J”，“a”，“v”，“a”组成的。
+ Java 没有内置的字符串类型，而是在标准 Java 类库中提供了一个预定义的类 String，每个用双引号括起来的字符串都是 String 类。

另外
```
String s1 = null;
String s2 = "";     //虽然s2也是空字符串，但是跟s1的null不同，他是创建了一个字符串s2但内容是空
```
**String 类和常量池**

常量池分为三种：全局字符串常量池，class 文件常量池，运行时常量池（Runtime Constant Pool）。

每个 class 加载以后都有一个运行时常量池

```
String a = "乔木";                  //a 直接引用常量池中的"乔木"
String b = "乔木";                  //b 也直接引用常量池中的"乔木"，所以他们俩指的是同一个对象
String c = new String("乔木");      //c 因为自己又 new 了个 String，所以在堆里会有个新对象，只不过里面的数组还是"乔木"

System.out.println(a == b);         //true    因为 a 等于 b，是同一个对象，所以是 true
System.out.println(a == c);         //false   因为 c 创建了个新对象，不是同一个对象，所以这里是 false 
System.out.println(a.equals(c));    //true    equals 比较的是里面的字符是不是相等，这里两个都是"乔木"，所以这里也是 trus
```

比较字符串时通常都会使用 eauals，因为我们一般都是比较字符

> 对makedown语法逐渐熟悉起来后,可以把之前页面不清晰的地方重新改一下,自己复习起来也更容易.加油!

3/13

## String 类常用的方法

**String 类常用方法列表**

|**方法**                                             |**解释说明**                                        |
|:-:                                                  |:-:                                                |
|char charAt(int index)                               |返回字符串中第 index 个字符                         |
|boolean equals(String other)                         |如果字符串与 other相等，则返回 true;否则，返回 false；|
|int indexOf(String str)                              |返回从头开始查找第一个子字符串 str 在字符串中的索引位置。如果未找到字符串，则返回-1 |
|lastlndexOf()                                        |返回从末尾开始查找第一个字符串 str 在字符串中的索引位置。如果未找到字符串 str，则返回-1|
|int length()                                         |返回字符串的长度|
|String replace(char oldChar,char newChar)            |返回一个新串，它是通过用 newChar 替换此字符串中出现的所有 oldChar 而生成的。|
|boolean startsWith(String prefix)                    |如果字符串以 prefix 开始，则返回 true|
|boolean endsWith(String prefix)                      |如果字符串以 prefix 结尾，则返回 true|
|String substring(int beginlndex)                     |返回一个新字符串，该串包含从原始字符串 beginlndex 到串尾|
|String substring(int beginlndex,int endlndex)        |返回一个新字符串，该串包含从原始字符串 beginlndex 到串尾或 endlndex-1 的所有字符|
|String toLowerCase()                                 |返回一个新字符串，该串将原始字符串中的所有大写字母改成小写字母|
|String toUpperCase()                                 |返回一个新字符串，该串将原始字符串中的所有小写字母改成大写字母|
|String trim()                                        |返回一个新字符串，该串删除了原始字符串头部和尾部的空格|
